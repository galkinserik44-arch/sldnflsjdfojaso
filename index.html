<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TURRET CHESS - GRANDMASTER EDITION</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        :root { --bg: #161512; --panel: #262421; --accent: #4caf50; --white-cell: #f0d9b5; --black-cell: #b58863; --highlight: rgba(246, 246, 105, 0.8); }
        body { background: var(--bg); color: #bababa; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; margin: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; overflow: hidden; }
        
        #app-container { display: flex; gap: 20px; align-items: flex-start; max-width: 95vw; }
        @media (max-width: 800px) { #app-container { flex-direction: column; align-items: center; } }

        /* Board Styling */
        #board-wrapper { position: relative; border: 4px solid #3d3b38; border-radius: 4px; box-shadow: 0 5px 30px rgba(0,0,0,0.5); }
        #board { display: grid; grid-template-columns: repeat(8, 65px); grid-template-rows: repeat(8, 65px); background: #333; user-select: none; }
        @media (max-width: 550px) { #board { grid-template-columns: repeat(8, 11.5vw); grid-template-rows: repeat(8, 11.5vw); } }
        
        .cell { width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; font-size: 45px; cursor: pointer; position: relative; transition: background 0.1s; }
        @media (max-width: 550px) { .cell { font-size: 32px; } }
        .white-cell { background: var(--white-cell); color: #333; }
        .black-cell { background: var(--black-cell); color: #fff; }
        .piece-white { color: #fff; text-shadow: 2px 2px #000; }
        .piece-black { color: #000; text-shadow: 0px 0px 2px #fff; }
        
        /* Highlights */
        .selected { background: var(--highlight) !important; }
        .valid-move::after { content: ''; width: 25%; height: 25%; background: rgba(0,0,0,0.15); border-radius: 50%; position: absolute; }
        .valid-shoot { background: rgba(255, 82, 82, 0.6) !important; box-shadow: inset 0 0 15px #000; }
        .valid-shoot::after { content: 'üéØ'; font-size: 16px; position: absolute; opacity: 0.8; }
        .valid-castle { background: rgba(66, 165, 245, 0.6) !important; }

        /* HP Bars */
        .hp-bar { position: absolute; top: 2px; left: 4px; right: 4px; height: 5px; background: rgba(0,0,0,0.5); border-radius: 2px; overflow: hidden; pointer-events: none; border: 1px solid rgba(255,255,255,0.1); }
        .hp-fill { height: 100%; background: #62d62d; transition: width 0.3s; }

        /* Sidebar Styling */
        #sidebar { width: 260px; background: var(--panel); border-radius: 4px; padding: 15px; display: flex; flex-direction: column; gap: 15px; }
        @media (max-width: 800px) { #sidebar { width: 90vw; } }
        
        .status-card { background: #1c1a17; padding: 10px; border-radius: 4px; text-align: center; }
        .turn-indicator { font-weight: bold; font-size: 20px; text-transform: uppercase; margin-bottom: 5px; }
        .btn { background: #403d39; border: none; color: #bababa; padding: 10px; border-radius: 4px; font-weight: bold; cursor: pointer; text-transform: uppercase; transition: all 0.2s; }
        .btn:hover { background: #504d48; color: #fff; }
        .btn-main { background: var(--accent); color: #fff; }
        .btn-main:hover { background: #66bb6a; }
        .btn-red { background: #af4c4c; color: #fff; }

        /* FX Layer */
        .fx-layer { position: absolute; top: 0; left: 0; pointer-events: none; z-index: 100; width: 100%; height: 100%; }
        .bullet { position: absolute; width: 10px; height: 10px; background: #fff; border-radius: 50%; box-shadow: 0 0 15px #fff; margin-left: -5px; margin-top: -5px; }
        .explosion { position: absolute; width: 50px; height: 50px; background: radial-gradient(circle, #fff, transparent); border-radius: 50%; animation: explode 0.3s forwards; margin-left: -25px; margin-top: -25px; }
        @keyframes explode { 0% { transform: scale(0.1); opacity: 1; } 100% { transform: scale(1.5); opacity: 0; } }

        /* Lobby */
        #lobby-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: var(--bg); z-index: 1000; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .lobby-box { background: var(--panel); padding: 30px; border-radius: 8px; text-align: center; border: 1px solid #3d3b38; }

        /* Rematch Modal */
        #modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 2000; flex-direction: column; align-items: center; justify-content: center; }
        #modal-box { background: var(--panel); padding: 40px; border-radius: 8px; text-align: center; border: 2px solid var(--accent); }
    </style>
</head>
<body>

    <div id="lobby-overlay">
        <div class="lobby-box">
            <h1 style="color: #fff; margin-top: 0;">TURRET CHESS</h1>
            <div id="lobby-status" style="font-size: 14px; margin: 15px 0;">–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–µ—Ç–∏...</div>
            <div id="id-display-box" style="display:none">
                <div id="my-id" onclick="copyId()" style="background: #1c1a1a; padding: 12px; border-radius: 4px; font-weight: bold; color: var(--accent); cursor: pointer; border: 1px solid #333; margin-bottom: 10px;">----</div>
                <button class="btn btn-main" onclick="copyInvite()">–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Å—Å—ã–ª–∫—É</button>
                <div style="margin: 20px 0; height: 1px; background: #333;"></div>
                <input type="text" id="target-id" placeholder="ID –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞" style="background: #1c1a1a; border: 1px solid #333; color: #fff; padding: 12px; width: 200px; border-radius: 4px; text-align: center; margin-bottom: 10px;">
                <button class="btn" style="width: 100%;" onclick="joinRoom()">–ü—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è</button>
            </div>
        </div>
    </div>

    <div id="app-container">
        <div id="board-wrapper">
            <div id="board" oncontextmenu="return false;"></div>
            <div id="fx-layer" class="fx-layer"></div>
        </div>

        <div id="sidebar">
            <div class="status-card">
                <div id="turn-txt" class="turn-indicator">–û–ñ–ò–î–ê–ù–ò–ï</div>
                <div id="my-color-txt" style="font-size: 12px; color: #888;">---</div>
            </div>
            
            <button id="end-turn-btn" class="btn btn-main" style="display:none;" onclick="manualEndTurn()">–ó–∞–≤–µ—Ä—à–∏—Ç—å —Ö–æ–¥</button>
            
            <div style="flex-grow: 1;"></div>
            
            <button class="btn" onclick="location.reload()">–í—ã–π—Ç–∏ –≤ –º–µ–Ω—é</button>
            <div style="font-size: 10px; color: #555; text-align: center;">V19.0 GRANDMASTER ONLINE</div>
        </div>
    </div>

    <div id="modal">
        <div id="modal-box">
            <h1 id="win-msg" style="color:#fff;">–ü–û–ë–ï–î–ê!</h1>
            <button id="rematch-btn" class="btn btn-main" style="width: 200px;" onclick="requestRematch()">–†–µ–≤–∞–Ω—à</button>
            <div id="rematch-status" style="margin-top: 10px; font-size: 12px;"></div>
        </div>
    </div>

    <script>
        const CONFIG = { p:{hp:2,d:1}, r:{hp:7,d:3}, n:{hp:4,d:2}, b:{hp:4,d:2}, q:{hp:10,d:3}, k:{hp:15,d:1} };
        const ICONS = { white:{p:'‚ôô',r:'‚ôñ',n:'‚ôò',b:'‚ôó',q:'‚ôï',k:'‚ôî'}, black:{p:'‚ôü',r:'‚ôú',n:'‚ôû',b:'‚ôù',q:'‚ôõ',k:'‚ôö'} };
        let board=[], sel=null, moves=[], shoots=[], turn='white', myCol=null, peer, conn, isBusy=false, hasMoved=false;
        const audio = new (window.AudioContext || window.webkitAudioContext)();

        function play(f,t,d){ try{const o=audio.createOscillator(),g=audio.createGain();o.type=t;o.frequency.setValueAtTime(f,audio.currentTime);g.gain.setValueAtTime(0.1,audio.currentTime);o.connect(g);g.connect(audio.destination);o.start();o.stop(audio.currentTime+d);}catch(e){} }

        function initNetwork() {
            peer = new Peer({config:{iceServers:[{urls:'stun:stun.l.google.com:19302'}]}});
            peer.on('open', id => {
                document.getElementById('lobby-status').innerText = "–ì–æ—Ç–æ–≤ –∫ –∏–≥—Ä–µ";
                document.getElementById('my-id').innerText = id;
                document.getElementById('id-display-box').style.display = 'block';
                const joinId = new URLSearchParams(window.location.search).get('join');
                if(joinId) { document.getElementById('target-id').value = joinId; joinRoom(); }
            });
            peer.on('connection', c => {
                if(conn) return;
                conn = c; myCol = 'white'; setupConn();
            });
            peer.on('error', e => alert("–û—à–∏–±–∫–∞ —Å–µ—Ç–∏: " + e.type));
        }

        function joinRoom() {
            const id = document.getElementById('target-id').value.trim();
            if(!id) return;
            myCol = 'black';
            conn = peer.connect(id);
            setupConn();
        }

        function setupConn() {
            conn.on('open', () => {
                document.getElementById('lobby-overlay').style.display = 'none';
                startNewGame();
            });
            conn.on('data', d => {
                if(d.type === 'action') applyRemoteAction(d);
                if(d.type === 'rematch_req') { if(confirm("–ü—Ä–æ—Ç–∏–≤–Ω–∏–∫ —Ö–æ—á–µ—Ç —Ä–µ–≤–∞–Ω—à!")) { conn.send({type:'rematch_ok'}); startNewGame(); } }
                if(d.type === 'rematch_ok') startNewGame();
            });
        }

        async function applyRemoteAction(d) {
            isBusy = true;
            if(d.move) {
                const p = board[d.move.fR][d.move.fC];
                if(d.move.castle === 'short') { board[d.move.tR][d.move.tC-1] = board[d.move.tR][d.move.tC+1]; board[d.move.tR][d.move.tC+1] = null; }
                if(d.move.castle === 'long') { board[d.move.tR][d.move.tC+1] = board[d.move.tR][d.move.tC-2]; board[d.move.tR][d.move.tC-2] = null; }
                board[d.move.tR][d.move.tC] = p; board[d.move.fR][d.move.fC] = null;
                p.m = true; play(300, 'sine', 0.1);
            }
            if(d.shoot) {
                await shootFX(d.shoot.fR, d.shoot.fC, d.shoot.tR, d.shoot.tC);
                const target = board[d.shoot.tR][d.shoot.tC];
                if(target) { target.hp -= d.shoot.d; if(target.hp <= 0) { const isK = target.t === 'k'; board[d.shoot.tR][d.shoot.tC] = null; if(isK) endGame(target.c); } }
            }
            turn = d.next; isBusy = false; render();
        }

        function startNewGame() {
            board = Array(8).fill().map(() => Array(8).fill(null));
            for(let i=0; i<8; i++) {
                board[1][i] = {t:'p', c:'black', hp:2, m:false};
                board[6][i] = {t:'p', c:'white', hp:2, m:false};
            }
            const l = ['r','n','b','q','k','b','n','r'];
            l.forEach((p, i) => {
                board[0][i] = {t:p, c:'black', hp:CONFIG[p].hp, m:false};
                board[7][i] = {t:p, c:'white', hp:CONFIG[p].hp, m:false};
            });
            turn = 'white'; myColText(); hasMoved = false; sel = null; isBusy = false;
            document.getElementById('modal').style.display = 'none'; render();
        }

        function myColText() {
            const el = document.getElementById('my-color-txt');
            el.innerText = "–í–´ –ò–ì–†–ê–ï–¢–ï –ó–ê " + (myCol === 'white' ? "–ë–ï–õ–´–•" : "–ß–ï–†–ù–´–•");
            el.style.color = myCol === 'white' ? '#fff' : '#888';
        }

        function render() {
            const el = document.getElementById('board'); el.innerHTML = '';
            // Rotate board for black
            const indices = [0,1,2,3,4,5,6,7];
            const rows = myCol === 'black' ? indices : [...indices].reverse();
            const cols = myCol === 'black' ? [...indices].reverse() : indices;

            for(let r of rows) {
                for(let c of cols) {
                    const cell = document.createElement('div');
                    cell.className = `cell ${(r+c)%2===0 ? 'white-cell' : 'black-cell'}`;
                    const p = board[r][c];
                    if(p) {
                        cell.innerText = ICONS[p.c][p.t];
                        cell.classList.add('piece-'+p.c);
                        const hb = document.createElement('div'); hb.className='hp-bar';
                        const hf = document.createElement('div'); hf.className='hp-fill';
                        hf.style.width = (p.hp/CONFIG[p.t].hp*100)+'%'; hb.appendChild(hf); cell.appendChild(hb);
                    }
                    cell.onmousedown = (e) => { if(audio.state==='suspended') audio.resume(); handleClick(r,c,e); };
                    if(sel && sel.r===r && sel.c===c) cell.classList.add('selected');
                    if(moves.some(m=>m.r===r&&m.c===c)) { cell.classList.add('valid-move'); if(moves.find(m=>m.r===r&&m.c===c).castle) cell.classList.add('valid-castle'); }
                    if(shoots.some(m=>m.r===r&&m.c===c)) cell.classList.add('valid-shoot');
                    el.appendChild(cell);
                }
            }
            const st = document.getElementById('turn-txt');
            st.innerText = turn === myCol ? "–í–ê–® –•–û–î" : "–•–û–î –ü–†–û–¢–ò–í–ù–ò–ö–ê";
            st.style.color = turn === 'white' ? '#fff' : '#888';
            document.getElementById('end-turn-btn').style.display = (hasMoved && turn === myCol) ? 'block' : 'none';
        }

        async function handleClick(r, c, e) {
            if(turn !== myCol || isBusy) return;
            const p = board[r][c];

            if(!hasMoved) {
                if(p && p.c === turn) {
                    sel = {r, c};
                    if(e.button === 0) { moves = getMoves(r, c, false); shoots = []; }
                    else { shoots = getMoves(r, c, true); moves = []; }
                } else if(sel) {
                    const m = moves.find(v=>v.r===r && v.c===c);
                    const s = shoots.find(v=>v.r===r && v.c===c);
                    if(m) {
                        isBusy = true;
                        const act = { type:'action', move:{fR:sel.r, fC:sel.c, tR:r, tC:c, castle:m.castle}, next:turn };
                        if(m.castle) {
                            if(m.castle === 'short') { board[r][c-1] = board[r][c+1]; board[r][c+1] = null; }
                            else { board[r][c+1] = board[r][c-2]; board[r][c-2] = null; }
                        }
                        board[r][c] = {...board[sel.r][sel.c], m:true}; board[sel.r][sel.c] = null; sel = {r, c};
                        play(300, 'sine', 0.1); hasMoved = true; moves = []; shoots = getMoves(r, c, true);
                        if(shoots.length === 0) finalize(act); else { isBusy = false; if(conn) conn.send(act); }
                    } else if(s) {
                        isBusy = true;
                        const act = { type:'action', shoot:{fR:sel.r, fC:sel.c, tR:r, tC:c, d:CONFIG[board[sel.r][sel.c].t].d}, next:turn==='white'?'black':'white' };
                        await shootFX(sel.r, sel.c, r, c);
                        board[r][c].hp -= act.shoot.d; if(board[r][c].hp <= 0) { const ik = board[r][c].t === 'k'; board[r][c] = null; if(ik) checkWin(); }
                        finalize(act);
                    } else { sel = null; moves = []; shoots = []; }
                }
            } else { // After move
                const s = shoots.find(v=>v.r===r && v.c===c);
                if(s) {
                    isBusy = true;
                    const act = { type:'action', shoot:{fR:sel.r, fC:sel.c, tR:r, tC:c, d:CONFIG[board[sel.r][sel.c].t].d}, next:turn==='white'?'black':'white' };
                    await shootFX(sel.r, sel.c, r, c);
                    if(board[r][c]) { board[r][c].hp -= act.shoot.d; if(board[r][c].hp <= 0) { const ik = board[r][c].t === 'k'; board[r][c] = null; if(ik) checkWin(); } }
                    finalize(act);
                }
            }
            render();
        }

        function finalize(act) {
            turn = turn==='white' ? 'black' : 'white'; act.next = turn;
            sel = null; moves = []; shoots = []; hasMoved = false; isBusy = false;
            if(conn) conn.send(act); render();
        }

        function manualEndTurn() { if(turn === myCol) finalize({type:'action'}); }

        function getMoves(r,c,isS) {
            let res=[]; const p=board[r][c]; if(!p) return []; const dr=p.c==='white'?-1:1;
            if(p.t==='p') {
                if(!isS) {
                    if(r+dr>=0 && r+dr<8 && !board[r+dr][c]) { res.push({r:r+dr,c}); if(!p.m && !board[r+2*dr][c]) res.push({r:r+2*dr,c}); }
                    [[dr,1],[dr,-1]].forEach(v=>{ let nr=r+v[0], nc=c+v[1]; if(nr>=0&&nr<8&&nc>=0&&nc<8&&board[nr][nc]&&board[nr][nc].c!==p.c&&board[nr][nc].t!=='k') res.push({r:nr,c:nc}); });
                } else [[dr,1],[dr,-1]].forEach(v=>{ let nr=r+v[0], nc=c+v[1]; if(nr>=0&&nr<8&&nc>=0&&nc<8&&board[nr][nc]&&board[nr][nc].c!==p.c) res.push({r:nr,c:nc}); });
            } else if(p.t==='n') {
                [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]].forEach(v=>{ let nr=r+v[0], nc=c+v[1]; if(nr>=0&&nr<8&&nc>=0&&nc<8 && (!board[nr][nc] || (board[nr][nc].c!==p.c && (isS || board[nr][nc].t!=='k')))) res.push({r:nr,c:nc}); });
            } else if(p.t==='k') {
                for(let i=-1;i<=1;i++) for(let j=-1;j<=1;j++) { if(i===0&&j===0)continue; let nr=r+i, nc=c+j; if(nr>=0&&nr<8&&nc>=0&&nc<8 && (!board[nr][nc] || (board[nr][nc].c!==p.c && (isS || board[nr][nc].t!=='k')))) res.push({r:nr,c:nc}); }
                if(!isS && !p.m) {
                    if(!board[r][c+1] && !board[r][c+2] && board[r][c+3]?.t==='r' && !board[r][c+3].m) res.push({r:r,c:c+2,castle:'short'});
                    if(!board[r][c-1] && !board[r][c-2] && !board[r][c-3] && board[r][c-4]?.t==='r' && !board[r][c-4].m) res.push({r:r,c:c-2,castle:'long'});
                }
            } else {
                const dirs = p.t==='r' ? [[0,1],[0,-1],[1,0],[-1,0]] : p.t==='b' ? [[1,1],[1,-1],[-1,1],[-1,-1]] : [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
                dirs.forEach(v=>{ for(let i=1;i<8;i++){ let nr=r+v[0]*i, nc=c+v[1]*i; if(nr<0||nr>=8||nc<0||nc>=8)break; if(!board[nr][nc]){if(!isS)res.push({r:nr,c:nc});} else {if(board[nr][nc].c!==p.c&&(isS||board[nr][nc].t!=='k'))res.push({r:nr,c:nc}); break;} } });
            }
            return res;
        }

        async function shootFX(fr,fc,tr,tc) {
            const layer=document.getElementById('fx-layer'), rect=document.getElementById('board').getBoundingClientRect(), cw=rect.width/8;
            function getC(r,c) { let dr=myCol==='black'?r:7-r, dc=myCol==='black'?7-c:c; return { x:dc*cw+cw/2, y:dr*cw+cw/2 }; }
            const s=getC(fr,fc), e=getC(tr,tc), b=document.createElement('div'); b.className='bullet'; b.style.left=s.x+'px'; b.style.top=s.y+'px';
            layer.appendChild(b); play(400,'sawtooth',0.1);
            return new Promise(res => { const start=performance.now(); function anim(t){ const p=Math.min((t-start)/300,1); b.style.left=s.x+(e.x-s.x)*p+'px'; b.style.top=s.y+(e.y-s.y)*p+'px'; if(p<1)requestAnimationFrame(anim); else { b.remove(); const ex=document.createElement('div'); ex.className='explosion'; ex.style.left=e.x+'px'; ex.style.top=e.y+'px'; layer.appendChild(ex); play(100,'square',0.2); setTimeout(()=>{ex.remove(); res();},300); } } requestAnimationFrame(anim); });
        }

        function checkWin() {
            let wK=false, bK=false;
            for(let r=0;r<8;r++) for(let c=0;c<8;c++) if(board[r][c]?.t==='k') { if(board[r][c].c==='white') wK=true; else bK=true; }
            if(!wK || !bK) endGame(wK?'black':'white');
        }

        function endGame(lostColor) {
            document.getElementById('win-msg').innerText = lostColor==='white' ? "–ß–ï–†–ù–´–ï –ü–û–ë–ï–î–ò–õ–ò!" : "–ë–ï–õ–´–ï –ü–û–ë–ï–î–ò–õ–ò!";
            document.getElementById('modal').style.display='flex';
        }

        function requestRematch() { if(conn) { conn.send({type:'rematch_req'}); document.getElementById('rematch-status').innerText = "–ó–∞–ø—Ä–æ—Å –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω..."; } }
        function copyInvite() { navigator.clipboard.writeText(window.location.origin+window.location.pathname+"?join="+document.getElementById('my-id').innerText); alert("–°—Å—ã–ª–∫–∞ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∞!"); }
        function copyId() { navigator.clipboard.writeText(document.getElementById('my-id').innerText); alert("ID —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω!"); }

        initNetwork();
    </script>
</body>
</html>