<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TURRET CHESS v18.0 - ABSOLUTE CONTROL</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        body { background: #0a0a0a; color: #fff; font-family: sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; margin: 0; overflow: hidden; }
        #lobby { background: #000; padding: 30px; border-radius: 15px; text-align: center; border: 2px solid #4caf50; width: 280px; box-shadow: 0 0 40px #000; }
        #game-ui { display: none; flex-direction: column; align-items: center; width: 100%; }
        #board-wrapper { position: relative; padding: 8px; background: #222; border-radius: 4px; box-shadow: 0 0 20px #000; }
        #board { display: grid; grid-template-columns: repeat(8, 60px); grid-template-rows: repeat(8, 60px); background: #333; position: relative; }
        @media (max-width: 500px) { #board { grid-template-columns: repeat(8, 11vw); grid-template-rows: repeat(8, 11vw); } .cell { width: 11vw !important; height: 11vw !important; font-size: 26px !important; } }
        .cell { width: 60px; height: 60px; display: flex; align-items: center; justify-content: center; font-size: 40px; cursor: pointer; position: relative; z-index: 10; user-select: none; }
        .white-cell { background: #eeeed2; color: #333; }
        .black-cell { background: #769656; color: #fff; }
        .piece-white { color: #fff; text-shadow: 2px 2px #000; }
        .piece-black { color: #000; text-shadow: 0px 0px 2px #fff; }
        .selected { background: #f6f669 !important; }
        .valid-move::after { content: ''; width: 12px; height: 12px; background: rgba(0,0,0,0.3); border-radius: 50%; position: absolute; }
        .valid-shoot { background: #ff5252 !important; box-shadow: inset 0 0 10px #000; }
        .valid-castle { background: #42a5f5 !important; }
        .hp-bar { position: absolute; top: 1px; left: 3px; right: 3px; height: 4px; background: #000; border-radius: 2px; overflow: hidden; pointer-events: none; }
        .hp-fill { height: 100%; background: #0f0; transition: width 0.3s; }
        .btn { background: #4caf50; border: none; color: white; padding: 12px; font-weight: bold; cursor: pointer; border-radius: 8px; width: 100%; text-transform: uppercase; margin-top: 8px; }
        #status-bar { font-size: 16px; margin-bottom: 8px; font-weight: bold; }
        .fx-layer { position: absolute; top: 0; left: 0; pointer-events: none; z-index: 100; width: 100%; height: 100%; }
        .bullet { position: absolute; width: 10px; height: 10px; background: #ff0; border-radius: 50%; box-shadow: 0 0 15px #f90; margin: -5px 0 0 -5px; }
        .explosion { position: absolute; width: 50px; height: 50px; background: radial-gradient(circle, #f90, transparent); border-radius: 50%; animation: explode 0.3s forwards; margin: -25px 0 0 -25px; }
        @keyframes explode { 0% { transform: scale(0.1); opacity: 1; } 100% { transform: scale(1.4); opacity: 0; } }
        #rematch-modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 1000; flex-direction: column; align-items: center; justify-content: center; }
    </style>
</head>
<body>

    <div id="lobby">
        <h2 style="margin:0">TURRET CHESS</h2>
        <div id="lobby-status" style="font-size:11px; color:#ffeb3b; margin:10px 0;">Инициализация...</div>
        <div id="lobby-ui" style="display:none">
            <div id="my-id" onclick="copyInvite()" style="font-weight:bold; color:#4caf50; background:#1a1a1a; padding:10px; border-radius:5px; margin:10px 0; cursor:pointer; font-size:14px;">----</div>
            <button class="btn" style="background:#ff9800; font-size:11px;" onclick="copyInvite()">СКОПИРОВАТЬ ССЫЛКУ</button>
            <div style="height:1px; background:#333; margin:15px 0;"></div>
            <input type="text" id="target-id" placeholder="ID друга" style="width:80%; padding:10px; text-align:center; background:#222; color:#fff; border:none; border-radius:5px; margin-bottom:10px;">
            <button class="btn" style="background:#2196f3" onclick="joinRoom()">ИГРАТЬ</button>
        </div>
    </div>

    <div id="game-ui">
        <div id="status-bar">ОЖИДАНИЕ...</div>
        <div id="board-wrapper">
            <div id="board" oncontextmenu="return false;"></div>
            <div id="fx-layer" class="fx-layer"></div>
        </div>
        <button id="end-turn-btn" class="btn" style="display:none; background:#ff5252;" onclick="manualEndTurn()">ЗАВЕРШИТЬ ХОД</button>
    </div>

    <div id="rematch-modal">
        <h1 id="win-msg">ПОБЕДА!</h1>
        <button class="btn" style="width:200px" onclick="sendRematch()">РЕВАНШ</button>
        <p id="rematch-msg" style="font-size:12px; color:#666; margin-top:10px"></p>
    </div>

    <script>
        const config = { p:{hp:2,d:1}, r:{hp:7,d:3}, n:{hp:4,d:2}, b:{hp:4,d:2}, q:{hp:10,d:3}, k:{hp:15,d:1} };
        const icons = { white:{p:'♙',r:'♖',n:'♘',b:'♗',q:'♕',k:'♔'}, black:{p:'♟',r:'♜',n:'♞',b:'♝',q:'♛',k:'♚'} };
        let board=[], sel=null, moves=[], shoots=[], turn='white', myCol=null, peer, conn, isProcessing=false, hasMoved=false;
        const audio = new (window.AudioContext || window.webkitAudioContext)();

        function play(f,t,d){ try{const o=audio.createOscillator(),g=audio.createGain();o.type=t;o.frequency.setValueAtTime(f,audio.currentTime);g.gain.setValueAtTime(0.1,audio.currentTime);o.connect(g);g.connect(audio.destination);o.start();o.stop(audio.currentTime+d);}catch(e){} }

        function initNetwork() {
            peer = new Peer({config:{iceServers:[{urls:'stun:stun.l.google.com:19302'}]}});
            peer.on('open', id => { document.getElementById('lobby-status').innerText="СЕТЬ ОК"; document.getElementById('my-id').innerText=id; document.getElementById('lobby-ui').style.display='block'; const u=new URLSearchParams(window.location.search).get('join'); if(u){document.getElementById('target-id').value=u; joinRoom();} });
            peer.on('connection', c => { if(conn)return; conn=c; myCol='white'; setupConn(); });
            peer.on('error', e => console.error(e));
        }

        function joinRoom() { const id=document.getElementById('target-id').value.trim(); if(!id)return; myCol='black'; conn=peer.connect(id); setupConn(); }

        function setupConn() {
            conn.on('open', () => { document.getElementById('lobby').style.display='none'; document.getElementById('game-ui').style.display='flex'; resetBoard(); });
            conn.on('data', d => {
                if(d.type==='action') applyAction(d);
                if(d.type==='rematch_req') { if(confirm("Противник хочет реванш!")) { conn.send({type:'rematch_ok'}); resetBoard(); } }
                if(d.type==='rematch_ok') resetBoard();
            });
        }

        async function applyAction(d) {
            isProcessing = true;
            if(d.move) {
                const p = board[d.move.fR][d.move.fC];
                if(d.move.c === 'short') { board[d.move.tR][d.move.tC-1]=board[d.move.tR][d.move.tC+1]; board[d.move.tR][d.move.tC+1]=null; }
                if(d.move.c === 'long') { board[d.move.tR][d.move.tC+1]=board[d.move.tR][d.move.tC-2]; board[d.move.tR][d.move.tC-2]=null; }
                board[d.move.tR][d.move.tC] = p; board[d.move.fR][d.move.fC] = null; p.m=true; play(300,'sine',0.1);
            }
            if(d.shoot) {
                await shootFX(d.shoot.fR, d.shoot.fC, d.shoot.tR, d.shoot.tC);
                const t = board[d.shoot.tR][d.shoot.tC];
                if(t) { t.hp -= d.shoot.d; if(t.hp<=0) { const isK=t.t==='k'; board[d.shoot.tR][d.shoot.tC]=null; if(isK) endGame(t.c); } }
            }
            turn = d.next; isProcessing = false; render();
        }

        function resetBoard() {
            board = Array(8).fill().map(()=>Array(8).fill(null));
            for(let i=0;i<8;i++) { board[1][i]={t:'p',c:'black',hp:2,m:false}; board[6][i]={t:'p',c:'white',hp:2,m:false}; }
            const l=['r','n','b','q','k','b','n','r'];
            l.forEach((p,i)=>{ board[0][i]={t:p,c:'black',hp:config[p].hp,m:false}; board[7][i]={t:p,c:'white',hp:config[p].hp,m:false}; });
            turn='white'; hasMoved=false; sel=null; isProcessing=false;
            document.getElementById('rematch-modal').style.display='none'; render();
        }

        function render() {
            const el = document.getElementById('board'); el.innerHTML = '';
            const rows = myCol==='black' ? [0,1,2,3,4,5,6,7] : [7,6,5,4,3,2,1,0];
            const cols = myCol==='black' ? [7,6,5,4,3,2,1,0] : [0,1,2,3,4,5,6,7];
            for(let r of rows) {
                for(let c of cols) {
                    const cell = document.createElement('div'); cell.className = `cell ${(r+c)%2===0?'white-cell':'black-cell'}`;
                    const p = board[r][c];
                    if(p) {
                        cell.innerText = icons[p.c][p.t]; cell.classList.add('piece-'+p.c);
                        const hb = document.createElement('div'); hb.className='hp-bar';
                        const hf = document.createElement('div'); hf.className='hp-fill';
                        hf.style.width = (p.hp/config[p.t].hp*100)+'%'; hb.appendChild(hf); cell.appendChild(hb);
                    }
                    cell.onmousedown = (e) => { if(audio.state==='suspended') audio.resume(); handleClick(r,c,e); };
                    if(sel && sel.r===r && sel.c===c) cell.classList.add('selected');
                    if(moves.some(m=>m.r===r&&m.c===c)) { cell.classList.add('valid-move'); if(moves.find(m=>m.r===r&&m.c===c).castle) cell.classList.add('valid-castle'); }
                    if(shoots.some(m=>m.r===r&&m.c===c)) cell.classList.add('valid-shoot');
                    el.appendChild(cell);
                }
            }
            document.getElementById('status-bar').innerText = turn===myCol ? "ТВОЙ ХОД" : "ЖДИ ВРАГА";
            document.getElementById('end-turn-btn').style.display = (hasMoved && turn===myCol) ? 'block' : 'none';
        }

        async function handleClick(r,c,e) {
            if(turn !== myCol || isProcessing) return;
            const p = board[r][c];

            if(!hasMoved) {
                if(p && p.c === turn) {
                    sel={r,c};
                    if(e.button===0) { moves=getMoves(r,c,false); shoots=[]; }
                    else { shoots=getMoves(r,c,true); moves=[]; }
                } else if (sel) {
                    const m = moves.find(v=>v.r===r&&v.c===c);
                    const s = shoots.find(v=>v.r===r&&v.c===c);
                    if(m) {
                        isProcessing = true;
                        const act = { type:'action', move:{fR:sel.r,fC:sel.c,tR:r,tC:c,c:m.castle}, next:turn };
                        if(m.castle) { if(m.castle==='short'){board[r][c-1]=board[r][c+1]; board[r][c+1]=null;} else {board[r][c+1]=board[r][c-2]; board[r][c-2]=null;} }
                        board[r][c]={...board[sel.r][sel.c], m:true}; board[sel.r][sel.c]=null; sel={r,c}; play(300,'sine',0.1);
                        hasMoved=true; moves=[]; shoots=getMoves(r,c,true);
                        if(shoots.length === 0) manualEndTurn(act);
                        else { isProcessing=false; if(conn) conn.send(act); }
                    } else if(s) {
                        isProcessing=true; const act={type:'action', shoot:{fR:sel.r,fC:sel.c,tR:r,tC:c,d:config[board[sel.r][sel.c].t].d}, next:turn==='white'?'black':'white'};
                        await shootFX(sel.r,sel.c,r,c);
                        board[r][c].hp -= act.shoot.d; if(board[r][c].hp<=0) { const isK=board[r][c].t==='k'; board[r][c]=null; if(isK) endGame(act.shoot.c); }
                        turn=act.next; hasMoved=false; sel=null; moves=[]; shoots=[]; isProcessing=false; if(conn) conn.send(act);
                    } else { sel=null; moves=[]; shoots=[]; }
                }
            } else { // Already moved, only shooting allowed
                const s = shoots.find(v=>v.r===r&&v.c===c);
                if(s) {
                    isProcessing=true; const act={type:'action', shoot:{fR:sel.r,fC:sel.c,tR:r,tC:c,d:config[board[sel.r][sel.c].t].d}, next:turn==='white'?'black':'white'};
                    await shootFX(sel.r,sel.c,r,c);
                    if(board[r][c]) { board[r][c].hp -= act.shoot.d; if(board[r][c].hp<=0) { const isK=board[r][c].t==='k'; board[r][c]=null; if(isK) endGame(act.shoot.c); } }
                    turn=act.next; hasMoved=false; sel=null; moves=[]; shoots=[]; isProcessing=false; if(conn) conn.send(act);
                }
            }
            render();
        }

        function manualEndTurn(overrideAct = null) {
            const nt = turn==='white'?'black':'white';
            const act = overrideAct || { type:'action', next: nt };
            act.next = nt; turn=nt; hasMoved=false; sel=null; moves=[]; shoots=[];
            if(conn) conn.send(act); render();
        }

        function getMoves(r,c,isS) {
            let res=[]; const p=board[r][c]; if(!p)return []; const dir=p.c==='white'?-1:1;
            if(p.t==='p') {
                if(!isS) {
                    if(r+dir>=0 && r+dir<8 && !board[r+dir][c]) { res.push({r:r+dir,c}); if(!p.m && !board[r+2*dir][c]) res.push({r:r+2*dir,c}); }
                    [[dir,1],[dir,-1]].forEach(v=>{ let nr=r+v[0], nc=c+v[1]; if(nr>=0&&nr<8&&nc>=0&&nc<8&&board[nr][nc]&&board[nr][nc].c!==p.c&&board[nr][nc].t!=='k') res.push({r:nr,c:nc}); });
                } else [[dir,1],[dir,-1]].forEach(v=>{ let nr=r+v[0], nc=c+v[1]; if(nr>=0&&nr<8&&nc>=0&&nc<8&&board[nr][nc]&&board[nr][nc].c!==p.c) res.push({r:nr,c:nc}); });
            } else if(p.t==='n') {
                [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]].forEach(v=>{ let nr=r+v[0], nc=c+v[1]; if(nr>=0&&nr<8&&nc>=0&&nc<8 && (!board[nr][nc] || (board[nr][nc].c!==p.c && (isS || board[nr][nc].t!=='k')))) res.push({r:nr,c:nc}); });
            } else if(p.t==='k') {
                for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++) { if(dr===0&&dc===0)continue; let nr=r+dr,nc=c+dc; if(nr>=0&&nr<8&&nc>=0&&nc<8 && (!board[nr][nc] || (board[nr][nc].c!==p.c && (isS || board[nr][nc].t!=='k')))) res.push({r:nr,c:nc}); }
                if(!isS && !p.m) {
                    if(!board[r][c+1] && !board[r][c+2] && board[r][c+3]?.t==='r' && !board[r][c+3].m) res.push({r:r,c:c+2,castle:'short'});
                    if(!board[r][c-1] && !board[r][c-2] && !board[r][c-3] && board[r][c-4]?.t==='r' && !board[r][c-4].m) res.push({r:r,c:c-2,castle:'long'});
                }
            } else {
                const dirs = p.t==='r' ? [[0,1],[0,-1],[1,0],[-1,0]] : p.t==='b' ? [[1,1],[1,-1],[-1,1],[-1,-1]] : [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
                dirs.forEach(v=>{ for(let i=1;i<8;i++){ let nr=r+v[0]*i, nc=c+v[1]*i; if(nr<0||nr>=8||nc<0||nc>=8)break; if(!board[nr][nc]){if(!isS)res.push({r:nr,c:nc});} else {if(board[nr][nc].c!==p.c&&(isS||board[nr][nc].t!=='k'))res.push({r:nr,c:nc}); break;} } });
            }
            return res;
        }

        async function shootFX(fr,fc,tr,tc) {
            const layer=document.getElementById('fx-layer'), rect=document.getElementById('board').getBoundingClientRect(), cw=rect.width/8;
            function getC(r,c) { let dr=myCol==='black'?r:7-r, dc=myCol==='black'?7-c:c; return { x:dc*cw+cw/2, y:dr*cw+cw/2 }; }
            const s=getC(fr,fc), e=getC(tr,tc), b=document.createElement('div'); b.className='bullet'; b.style.left=s.x+'px'; b.style.top=s.y+'px';
            layer.appendChild(b); play(400,'sawtooth',0.1);
            return new Promise(res => { const start=performance.now(); function anim(t){ const p=Math.min((t-start)/300,1); b.style.left=s.x+(e.x-s.x)*p+'px'; b.style.top=s.y+(e.y-s.y)*p+'px'; if(p<1)requestAnimationFrame(anim); else { b.remove(); const ex=document.createElement('div'); ex.className='explosion'; ex.style.left=e.x+'px'; ex.style.top=e.y+'px'; layer.appendChild(ex); play(100,'square',0.2); setTimeout(()=>{ex.remove(); res();},300); } } requestAnimationFrame(anim); });
        }

        function endGame(lostColor) { document.getElementById('win-msg').innerText = lostColor==='white'?'ЧЕРНЫЕ ВЫИГРАЛИ!':'БЕЛЫЕ ВЫИГРАЛИ!'; document.getElementById('rematch-modal').style.display='flex'; }
        function sendRematch() { if(conn) { conn.send({type:'rematch_req'}); document.getElementById('rematch-msg').innerText="Запрос отправлен..."; } }
        function copyInvite() { navigator.clipboard.writeText(window.location.origin+window.location.pathname+"?join="+document.getElementById('my-id').innerText); alert("Ссылка скопирована!"); }
        initNetwork();
    </script>
</body>
</html>