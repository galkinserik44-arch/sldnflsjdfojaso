<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TURRET CHESS v17.1 - STABLE</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        body { background: #111; color: #fff; font-family: sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; margin: 0; overflow: hidden; }
        #lobby { background: #000; padding: 25px; border-radius: 15px; text-align: center; border: 2px solid #4caf50; width: 300px; }
        #game-ui { display: none; flex-direction: column; align-items: center; width: 100%; }
        #board-wrapper { position: relative; padding: 10px; background: #222; border-radius: 8px; border: 2px solid #444; }
        #board { display: grid; grid-template-columns: repeat(8, 60px); grid-template-rows: repeat(8, 60px); background: #333; position: relative; }
        @media (max-width: 500px) { #board { grid-template-columns: repeat(8, 11vw); grid-template-rows: repeat(8, 11vw); } .cell { width: 11vw !important; height: 11vw !important; font-size: 28px !important; } }
        .cell { width: 60px; height: 60px; display: flex; align-items: center; justify-content: center; font-size: 40px; cursor: pointer; position: relative; z-index: 10; user-select: none; }
        .white-cell { background: #eeeed2; color: #333; }
        .black-cell { background: #769656; color: #fff; }
        .piece-white { color: #fff; text-shadow: 2px 2px #000; }
        .piece-black { color: #000; text-shadow: 0px 0px 2px #fff; }
        .selected { background: #f6f669 !important; }
        .valid-move::after { content: ''; width: 12px; height: 12px; background: rgba(0,0,0,0.3); border-radius: 50%; position: absolute; }
        .valid-castle { background: #42a5f5 !important; }
        .valid-shoot { background: #ff5252 !important; box-shadow: inset 0 0 10px #000; }
        .hp-bar { position: absolute; top: 1px; left: 3px; right: 3px; height: 4px; background: #333; border: 1px solid #000; border-radius: 2px; overflow: hidden; pointer-events: none; }
        .hp-fill { height: 100%; background: #0f0; transition: width 0.3s; }
        .btn { background: #4caf50; border: none; color: white; padding: 12px; font-weight: bold; cursor: pointer; border-radius: 8px; width: 100%; text-transform: uppercase; margin-top: 10px; }
        #status-bar { font-size: 18px; margin-bottom: 10px; font-weight: bold; text-align: center; }
        .fx-layer { position: absolute; top: 0; left: 0; pointer-events: none; z-index: 100; width: 100%; height: 100%; }
        .bullet { position: absolute; width: 10px; height: 10px; background: #ff0; border-radius: 50%; box-shadow: 0 0 15px #f90; margin-left: -5px; margin-top: -5px; }
        .explosion { position: absolute; width: 50px; height: 50px; background: radial-gradient(circle, #f90, transparent); border-radius: 50%; animation: explode 0.3s ease-out forwards; margin-left: -25px; margin-top: -25px; }
        @keyframes explode { 0% { transform: scale(0.1); opacity: 1; } 100% { transform: scale(1.5); opacity: 0; } }
        #modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 2000; flex-direction: column; align-items: center; justify-content: center; }
        #modal-box { background: #222; padding: 40px; border-radius: 15px; border: 3px solid #4caf50; text-align: center; }
    </style>
</head>
<body>

    <div id="lobby">
        <h2 style="margin:0">TURRET CHESS</h2>
        <div id="lobby-status" style="font-size:12px; margin:10px 0; color:#ffeb3b">СЕТЬ: ЗАПУСК...</div>
        <div id="id-box" style="display:none">
            <div id="my-id" onclick="copyInvite()" style="cursor:pointer; font-weight:bold; font-size:16px; color:#4caf50; background:#222; padding:10px; border-radius:5px; margin:10px 0; word-break: break-all;">----</div>
            <button class="btn" style="background:#ff9800" onclick="copyInvite()">СКОПИРОВАТЬ ССЫЛКУ</button>
            <div style="margin: 15px 0; height: 1px; background: #333;"></div>
            <input type="text" id="target-id" placeholder="ID друга" style="padding:10px; width:80%; text-align:center; background:#333; color:#fff; border:none; border-radius:5px; margin-bottom:10px;">
            <button class="btn" style="background:#2196f3" onclick="joinRoom()">ИГРАТЬ</button>
        </div>
    </div>

    <div id="game-ui">
        <div id="status-bar">ОЖИДАНИЕ...</div>
        <div id="board-wrapper">
            <div id="board" oncontextmenu="return false;"></div>
            <div id="fx-layer" class="fx-layer"></div>
        </div>
        <button id="skip-shoot" class="btn" style="display:none; background:#ff5252;" onclick="skipShoot()">ЗАВЕРШИТЬ ХОД</button>
        <div style="margin-top:10px; font-size:10px; color:#666">ЛКМ: ХОД | ПКМ: ВЫСТРЕЛ</div>
    </div>

    <div id="modal">
        <div id="modal-box">
            <h1 id="winner-text">ПОБЕДА!</h1>
            <button id="rematch-btn" class="btn" onclick="requestRematch()">РЕВАНШ</button>
            <div id="rematch-status" style="font-size:12px; margin-top:10px; color:#aaa"></div>
        </div>
    </div>

    <script>
        const stats = { p:{hp:2,d:1}, r:{hp:7,d:3}, n:{hp:4,d:2}, b:{hp:4,d:2}, q:{hp:10,d:3}, k:{hp:15,d:1} };
        const icons = { white: { p: '♙', r: '♖', n: '♘', b: '♗', q: '♕', k: '♔' }, black: { p: '♟', r: '♜', n: '♞', b: '♝', q: '♛', k: '♚' } };
        let board=[], sel=null, moves=[], shoots=[], turn='white', myCol=null, peer, conn, isProcessing = false, gamePhase = 'select';
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        function play(f,t,d,v=0.1){ try{const o=audioCtx.createOscillator(),g=audioCtx.createGain();o.type=t;o.frequency.setValueAtTime(f,audioCtx.currentTime);o.frequency.exponentialRampToValueAtTime(10,audioCtx.currentTime+d);g.gain.setValueAtTime(v,audioCtx.currentTime);g.gain.exponentialRampToValueAtTime(0.01,audioCtx.currentTime+d);o.connect(g);g.connect(audioCtx.destination);o.start();o.stop(audioCtx.currentTime+d);}catch(e){} }

        function initNetwork() {
            peer = new Peer({ config: {'iceServers': [{urls:'stun:stun.l.google.com:19302'}, {urls:'stun:stun1.l.google.com:19302'}]}});
            peer.on('open', id => { document.getElementById('lobby-status').innerText = "СЕТЬ ГОТОВА"; document.getElementById('my-id').innerText = id; document.getElementById('id-box').style.display = 'block'; const uId = new URLSearchParams(window.location.search).get('join'); if (uId) { document.getElementById('target-id').value = uId; joinRoom(); } });
            peer.on('connection', c => { if(conn) return; conn = c; myCol = 'white'; setupConn(); });
        }

        function joinRoom() { const id = document.getElementById('target-id').value.trim(); if(!id) return; conn = peer.connect(id); myCol = 'black'; setupConn(); }

        function setupConn() {
            conn.on('open', () => { document.getElementById('lobby').style.display='none'; document.getElementById('game-ui').style.display='flex'; startNewGame(); });
            conn.on('data', d => { 
                if(d.type === 'action') handleRemoteAction(d); 
                if(d.type === 'REMATCH_REQ') { if(confirm("Противник хочет реванш!")) { conn.send({type:'REMATCH_ACCEPT'}); startNewGame(); } }
                if(d.type === 'REMATCH_ACCEPT') startNewGame();
            });
        }

        async function handleRemoteAction(d) {
            isProcessing = true;
            if(d.move) {
                play(300, 'sine', 0.1);
                const p = board[d.move.fR][d.move.fC];
                if(d.move.castle) {
                    if(d.move.castle==='short') { board[d.move.tR][d.move.tC-1] = board[d.move.tR][d.move.tC+1]; board[d.move.tR][d.move.tC+1] = null; }
                    else { board[d.move.tR][d.move.tC+1] = board[d.move.tR][d.move.tC-2]; board[d.move.tR][d.move.tC-2] = null; }
                }
                board[d.move.tR][d.move.tC] = p; board[d.move.fR][d.move.fC] = null; p.m = true;
            }
            if(d.shoot) {
                await shootFX(d.shoot.fR, d.shoot.fC, d.shoot.tR, d.shoot.tC);
                if(board[d.shoot.tR][d.shoot.tC]) { board[d.shoot.tR][d.shoot.tC].hp -= d.shoot.dmg; if(board[d.shoot.tR][d.shoot.tC].hp <= 0) { const ik = board[d.shoot.tR][d.shoot.tC].t==='k'; board[d.shoot.tR][d.shoot.tC]=null; if(ik) checkWin(); } }
            }
            turn = d.nextTurn; isProcessing = false; render();
        }

        function startNewGame() { board = Array(8).fill().map(() => Array(8).fill(null)); for(let i=0;i<8;i++){ board[1][i]={t:'p',c:'black',hp:2,m:false}; board[6][i]={t:'p',c:'white',hp:2,m:false}; } const l=['r','n','b','q','k','b','n','r']; l.forEach((p,i)=>{ board[0][i]={t:p,c:'black',hp:stats[p].hp,m:false}; board[7][i]={t:p,c:'white',hp:stats[p].hp,m:false}; }); turn='white'; gamePhase='select'; isProcessing=false; sel=null; document.getElementById('modal').style.display='none'; render(); }

        function render() {
            const el = document.getElementById('board'); el.innerHTML = '';
            // POV
            const rows = myCol === 'black' ? [0,1,2,3,4,5,6,7] : [7,6,5,4,3,2,1,0];
            const cols = myCol === 'black' ? [7,6,5,4,3,2,1,0] : [0,1,2,3,4,5,6,7];
            for(let r of rows) {
                for(let c of cols) {
                    const cell = document.createElement('div'); cell.className = `cell ${(r+c)%2===0?'white-cell':'black-cell'}`;
                    const p = board[r][c];
                    if(p) {
                        cell.innerText = icons[p.c][p.t]; cell.classList.add('piece-'+p.c);
                        const hb = document.createElement('div'); hb.className='hp-bar';
                        const hf = document.createElement('div'); hf.className='hp-fill';
                        hf.style.width = (p.hp/stats[p.t].hp*100)+'%'; hb.appendChild(hf); cell.appendChild(hb);
                    }
                    cell.onmousedown = (e) => { if(audioCtx.state==='suspended') audioCtx.resume(); handleClick(r,c,e); };
                    if(sel && sel.r===r && sel.c===c) cell.classList.add('selected');
                    if(moves.some(m=>m.r===r&&m.c===c)) { cell.classList.add('valid-move'); if(moves.find(m=>m.r===r&&m.c===c).castle) cell.classList.add('valid-castle'); }
                    if(shoots.some(m=>m.r===r&&m.c===c)) cell.classList.add('valid-shoot');
                    el.appendChild(cell);
                }
            }
            const sb = document.getElementById('status-bar'); sb.innerText = turn === myCol ? "ТВОЙ ХОД" : "ХОД ПРОТИВНИКА";
            sb.style.color = turn === 'white' ? '#fff' : '#ffeb3b';
            document.getElementById('skip-shoot').style.display = (gamePhase === 'moved' && turn === myCol) ? 'block' : 'none';
        }

        async function handleClick(r,c,e) {
            if(turn !== myCol || isProcessing) return;
            const p = board[r][c];

            if(gamePhase === 'select') {
                if(p && p.c === turn) {
                    sel = {r,c};
                    if(e.button === 0) { moves = getMoves(r,c,false); shoots = []; }
                    else { shoots = getMoves(r,c,true); moves = []; }
                } else { sel = null; moves = []; shoots = []; }
            } else if(gamePhase === 'moved') {
                const s = shoots.find(v=>v.r===r&&v.c===c);
                if(s) {
                    isProcessing = true; const dmg = stats[board[sel.r][sel.c].t].d; const nt = turn==='white'?'black':'white';
                    const action = { type:'action', shoot: {fR:sel.r, fC:sel.c, tR:r, tC:c, dmg: dmg}, nextTurn: nt };
                    await shootFX(sel.r, sel.c, r, c);
                    if(board[r][c]) { board[r][c].hp -= dmg; if(board[r][c].hp <= 0) { const ik = board[r][c].t==='k'; board[r][c]=null; if(ik) checkWin(); } }
                    finishAction(action);
                }
            }

            if(gamePhase === 'select' && sel) {
                const m = moves.find(v=>v.r===r&&v.c===c);
                const s = shoots.find(v=>v.r===r&&v.c===c);
                if(m) {
                    isProcessing = true; const action = { type:'action', move: {fR:sel.r, fC:sel.c, tR:r, tC:c, castle: m.castle}, nextTurn: turn };
                    if(m.castle) { if(m.castle==='short'){board[r][c-1]=board[r][c+1]; board[r][c+1]=null;} else {board[r][c+1]=board[r][c-2]; board[r][c-2]=null;} }
                    board[r][c] = {...board[sel.r][sel.c], m:true}; board[sel.r][sel.c]=null; sel={r,c};
                    moves = []; shoots = getMoves(r,c,true);
                    if(shoots.length === 0) { action.nextTurn = turn==='white'?'black':'white'; finishAction(action); }
                    else { gamePhase = 'moved'; isProcessing = false; if(conn) conn.send(action); }
                } else if(s && gamePhase === 'select') {
                    isProcessing = true; const dmg = stats[board[sel.r][sel.c].t].d; const nt = turn==='white'?'black':'white';
                    const action = { type:'action', shoot: {fR:sel.r, fC:sel.c, tR:r, tC:c, dmg: dmg}, nextTurn: nt };
                    await shootFX(sel.r, sel.c, r, c);
                    if(board[r][c]) { board[r][c].hp -= dmg; if(board[r][c].hp <= 0) { const ik = board[r][c].t==='k'; board[r][c]=null; if(ik) checkWin(); } }
                    finishAction(action);
                }
            }
            render();
        }

        function finishAction(action) { turn = action.nextTurn; sel=null; moves=[]; shoots=[]; gamePhase='select'; isProcessing=false; if(conn) conn.send(action); render(); }
        function skipShoot() { if(turn !== myCol) return; const nt = turn==='white'?'black':'white'; finishAction({type:'action', nextTurn: nt}); }

        function getMoves(r,c,isS) {
            let res=[]; const p=board[r][c]; if(!p) return []; const dir=p.c==='white'?-1:1;
            if(p.t==='p') {
                if(!isS) {
                    if(r+dir >= 0 && r+dir < 8 && !board[r+dir][c]) { res.push({r:r+dir,c}); if(!p.m && !board[r+2*dir][c]) res.push({r:r+2*dir,c}); }
                    [[dir,1],[dir,-1]].forEach(v=>{ let nr=r+v[0], nc=c+v[1]; if(nr>=0&&nr<8&&nc>=0&&nc<8&&board[nr][nc]&&board[nr][nc].c!==p.c&&board[nr][nc].t!=='k') res.push({r:nr,c:nc}); });
                } else [[dir,1],[dir,-1]].forEach(v=>{ let nr=r+v[0], nc=c+v[1]; if(nr>=0&&nr<8&&nc>=0&&nc<8&&board[nr][nc]&&board[nr][nc].c!==p.c) res.push({r:nr,c:nc}); });
            } else if(p.t==='n') {
                [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]].forEach(v=>{ let nr=r+v[0], nc=c+v[1]; if(nr>=0&&nr<8&&nc>=0&&nc<8){ if(!board[nr][nc] || (board[nr][nc].c!==p.c && (isS || board[nr][nc].t!=='k'))) res.push({r:nr,c:nc}); } });
            } else if(p.t==='k') {
                for(let dr=-1; dr<=1; dr++) for(let dc=-1; dc<=1; dc++) { if(dr===0&&dc===0)continue; let nr=r+dr, nc=c+dc; if(nr>=0&&nr<8&&nc>=0&&nc<8){ if(!board[nr][nc] || (board[nr][nc].c!==p.c && (isS || board[nr][nc].t!=='k'))) res.push({r:nr,c:nc}); } }
                if(!isS && !p.m) {
                    if(!board[r][c+1] && !board[r][c+2] && board[r][c+3] && board[r][c+3].t==='r' && !board[r][c+3].m) res.push({r:r,c:c+2,castle:'short'});
                    if(!board[r][c-1] && !board[r][c-2] && !board[r][c-3] && board[r][c-4] && board[r][c-4].t==='r' && !board[r][c-4].m) res.push({r:r,c:c-2,castle:'long'});
                }
            } else {
                const dirs = p.t==='r' ? [[0,1],[0,-1],[1,0],[-1,0]] : p.t==='b' ? [[1,1],[1,-1],[-1,1],[-1,-1]] : [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
                dirs.forEach(v=>{ for(let i=1;i<8;i++){ let nr=r+v[0]*i, nc=c+v[1]*i; if(nr<0||nr>=8||nc<0||nc>=8)break; if(!board[nr][nc]){if(!isS)res.push({r:nr,c:nc});} else {if(board[nr][nc].c!==p.c&&(isS||board[nr][nc].t!=='k'))res.push({r:nr,c:nc}); break;} } });
            }
            return res;
        }

        async function shootFX(fr, fc, tr, tc) {
            const layer = document.getElementById('fx-layer'), rect = document.getElementById('board').getBoundingClientRect(), cw = rect.width / 8;
            function getC(r, c) { let dr = myCol==='black'?r:7-r, dc = myCol==='black'?7-c:c; return { x: dc*cw+cw/2, y: dr*cw+cw/2 }; }
            const s=getC(fr,fc), e=getC(tr,tc), b=document.createElement('div'); b.className='bullet'; b.style.left=s.x+'px'; b.style.top=s.y+'px';
            layer.appendChild(b); play(400,'sawtooth',0.1);
            return new Promise(res => { const start=performance.now(); function anim(t){ const p=Math.min((t-start)/300,1); b.style.left=s.x+(e.x-s.x)*p+'px'; b.style.top=s.y+(e.y-s.y)*p+'px'; if(p<1)requestAnimationFrame(anim); else { b.remove(); const ex=document.createElement('div'); ex.className='explosion'; ex.style.left=e.x+'px'; ex.style.top=e.y+'px'; layer.appendChild(ex); play(100,'square',0.2,0.2); setTimeout(()=>{ex.remove(); res();},300); } } requestAnimationFrame(anim); });
        }

        function checkWin() {
            let wK = false, bK = false;
            for(let r=0; r<8; r++) for(let c=0; c<8; c++) if(board[r][c] && board[r][c].t === 'k') { if(board[r][c].c === 'white') wK = true; else bK = true; }
            if(!wK || !bK) { document.getElementById('winner-text').innerText = wK ? "БЕЛЫЕ ВЫИГРАЛИ!" : "ЧЕРНЫЕ ВЫИГРАЛИ!"; document.getElementById('modal').style.display = 'flex'; }
        }

        function requestRematch() { if(conn) conn.send({type:'REMATCH_REQ'}); document.getElementById('rematch-status').innerText = "ЗАПРОС ОТПРАВЛЕН..."; }
        function copyInvite() { navigator.clipboard.writeText(window.location.origin + window.location.pathname + "?join=" + document.getElementById('my-id').innerText); alert("ССЫЛКА СКОПИРОВАНА!"); }
        initNetwork();
    </script>
</body>
</html>