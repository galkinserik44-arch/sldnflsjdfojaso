<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TURRET CHESS ONLINE v14.0 - FULL SYNC</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        body { background: #1a1a1a; color: #fff; font-family: sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; margin: 0; overflow: hidden; }
        #lobby { background: #000; padding: 25px; border-radius: 15px; text-align: center; border: 2px solid #4caf50; width: 300px; box-shadow: 0 0 50px rgba(0,0,0,1); }
        #game-ui { display: none; flex-direction: column; align-items: center; width: 100%; }
        #board { display: grid; grid-template-columns: repeat(8, 60px); grid-template-rows: repeat(8, 60px); background: #444; position: relative; border: 5px solid #333; }
        @media (max-width: 500px) { #board { grid-template-columns: repeat(8, 11.5vw); grid-template-rows: repeat(8, 11.5vw); } .cell { width: 11.5vw !important; height: 11.5vw !important; font-size: 28px !important; } }
        .cell { width: 60px; height: 60px; display: flex; align-items: center; justify-content: center; font-size: 40px; cursor: pointer; position: relative; z-index: 1; transition: background 0.2s; }
        .white-cell { background: #eeeed2; color: #333; }
        .black-cell { background: #769656; color: #fff; }
        .piece-white { color: #fff; text-shadow: 2px 2px #000; }
        .piece-black { color: #000; text-shadow: 0px 0px 2px #fff; }
        .selected { background: #f6f669 !important; }
        .valid-move::after { content: ''; width: 12px; height: 12px; background: rgba(0,0,0,0.2); border-radius: 50%; position: absolute; }
        .valid-shoot { background: #ff5252 !important; box-shadow: inset 0 0 10px rgba(0,0,0,0.5); }
        .hp-bar { position: absolute; top: 1px; left: 3px; right: 3px; height: 4px; background: #333; border: 1px solid #000; border-radius: 2px; overflow: hidden; pointer-events: none; }
        .hp-fill { height: 100%; background: #0f0; transition: width 0.3s; }
        .btn { background: #4caf50; border: none; color: white; padding: 12px; font-weight: bold; cursor: pointer; border-radius: 8px; width: 100%; text-transform: uppercase; margin-top: 10px; box-shadow: 0 4px #2e7d32; }
        .btn:active { transform: translateY(2px); box-shadow: 0 2px #2e7d32; }
        #status-bar { font-size: 18px; margin-bottom: 10px; font-weight: bold; padding: 5px 15px; border-radius: 5px; }
        .fx-layer { position: absolute; top: 0; left: 0; pointer-events: none; z-index: 100; width: 100%; height: 100%; }
        .bullet { position: absolute; width: 10px; height: 10px; background: #ff0; border-radius: 50%; box-shadow: 0 0 15px #f90; }
        .explosion { position: absolute; width: 50px; height: 50px; background: radial-gradient(circle, #f90, transparent); border-radius: 50%; animation: explode 0.3s ease-out forwards; }
        @keyframes explode { 0% { transform: scale(0.1); opacity: 1; } 100% { transform: scale(1.5); opacity: 0; } }
    </style>
</head>
<body>

    <div id="lobby">
        <h2 style="margin:0">TURRET CHESS</h2>
        <div id="lobby-status" style="font-size:12px; margin:10px 0; color:#ffeb3b">СИНХРОНИЗАЦИЯ...</div>
        <div id="id-box" style="display:none">
            <div id="my-id" style="font-weight:bold; font-size:16px; color:#4caf50; background:#222; padding:10px; margin:10px 0; border-radius:5px; word-break: break-all;">----</div>
            <button class="btn" style="background:#ff9800" onclick="copyInvite()">КОПИРОВАТЬ ССЫЛКУ</button>
            <div style="margin: 15px 0; height: 1px; background: #333;"></div>
            <input type="text" id="target-id" placeholder="ID друга" style="padding:10px; width:80%; text-align:center; background:#333; color:#fff; border:none; border-radius:5px; margin-bottom:10px;">
            <button class="btn" style="background:#2196f3" onclick="joinRoom()">ИГРАТЬ</button>
        </div>
    </div>

    <div id="game-ui">
        <div id="status-bar">ОЖИДАНИЕ...</div>
        <div id="game-container">
            <div id="board" oncontextmenu="return false;"></div>
            <div id="fx-layer" class="fx-layer"></div>
        </div>
        <div style="margin-top:10px; font-size:10px; color:#666">ЛКМ: ХОД | ПКМ: ВЫСТРЕЛ</div>
    </div>

    <script>
        const stats = { p:{hp:2,d:1}, r:{hp:7,d:3}, n:{hp:4,d:2}, b:{hp:4,d:2}, q:{hp:10,d:3}, k:{hp:15,d:1} };
        let board=[], sel=null, moves=[], shoots=[], turn='white', myCol=null, peer, conn;
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        function play(f,t,d,v=0.1){
            try{const o=audioCtx.createOscillator(),g=audioCtx.createGain();o.type=t;o.frequency.setValueAtTime(f,audioCtx.currentTime);o.frequency.exponentialRampToValueAtTime(10,audioCtx.currentTime+d);g.gain.setValueAtTime(v,audioCtx.currentTime);g.gain.exponentialRampToValueAtTime(0.01,audioCtx.currentTime+d);o.connect(g);g.connect(audioCtx.destination);o.start();o.stop(audioCtx.currentTime+d);}catch(e){}
        }

        function init() {
            peer = new Peer({ config: {'iceServers': [{urls:'stun:stun.l.google.com:19302'}, {urls:'stun:stun1.l.google.com:19302'}]}});
            peer.on('open', id => {
                document.getElementById('lobby-status').innerText = "СЕТЬ ГОТОВА";
                document.getElementById('my-id').innerText = id;
                document.getElementById('id-box').style.display = 'block';
                const urlId = new URLSearchParams(window.location.search).get('join');
                if (urlId) { document.getElementById('target-id').value = urlId; joinRoom(); }
            });
            peer.on('connection', c => {
                if(conn) return;
                conn = c; myCol = 'white'; setupConn();
            });
        }

        function joinRoom() {
            const id = document.getElementById('target-id').value.trim();
            if(!id) return;
            conn = peer.connect(id);
            myCol = 'black';
            setupConn();
        }

        function setupConn() {
            conn.on('open', () => {
                document.getElementById('lobby').style.display='none';
                document.getElementById('game-ui').style.display='flex';
                initBoard();
                render();
                if(myCol === 'white') sync();
            });
            conn.on('data', d => {
                if(d.type === 'action') {
                    handleRemoteAction(d);
                } else if(d.type === 'sync') {
                    board = d.board; turn = d.turn; render();
                }
            });
        }

        async function handleRemoteAction(d) {
            if(d.move) {
                play(300, 'sine', 0.1);
                board[d.move.toR][d.move.toC] = board[d.move.fromR][d.move.fromC];
                board[d.move.fromR][d.move.fromC] = null;
                board[d.move.toR][d.move.toC].m = 1;
            }
            if(d.shoot) {
                await shootFX(d.shoot.fromR, d.shoot.fromC, d.shoot.toR, d.shoot.toC);
                board[d.shoot.toR][d.shoot.toC].hp -= d.shoot.dmg;
                if(board[d.shoot.toR][d.shoot.toC].hp <= 0) board[d.shoot.toR][d.shoot.toC] = null;
            }
            turn = d.nextTurn;
            render();
        }

        function sync() { if(conn && conn.open) conn.send({type:'sync', board, turn}); }

        function initBoard() {
            board = Array(8).fill().map(() => Array(8).fill(null));
            for(let i=0;i<8;i++) { board[1][i]={t:'p',c:'black',hp:2,m:0}; board[6][i]={t:'p',c:'white',hp:2,m:0}; }
            const l=['r','n','b','q','k','b','n','r'];
            l.forEach((p,i)=>{ board[0][i]={t:p,c:'black',hp:stats[p].hp,m:0}; board[7][i]={t:p,c:'white',hp:stats[p].hp,m:0}; });
        }

        function render() {
            const el = document.getElementById('board'); el.innerHTML = '';
            const isMyTurn = (turn === myCol);
            const rIdx = myCol==='black' ? [0,1,2,3,4,5,6,7] : [7,6,5,4,3,2,1,0];
            const cIdx = myCol==='black' ? [7,6,5,4,3,2,1,0] : [0,1,2,3,4,5,6,7];
            
            for(let r of rIdx) {
                for(let c of cIdx) {
                    const cell = document.createElement('div');
                    cell.className = `cell ${(r+c)%2===0?'white-cell':'black-cell'}`;
                    const p = board[r][c];
                    if(p) {
                        cell.innerText = {white:{p:'♙',r:'♖',n:'♘',b:'♗',q:'♕',k:'♔'},black:{p:'♟',r:'♜',n:'♞',b:'♝',q:'♛',k:'♚' }}[p.c][p.t];
                        cell.classList.add('piece-'+p.c);
                        const hb = document.createElement('div'); hb.className='hp-bar';
                        const hf = document.createElement('div'); hf.className='hp-fill';
                        hf.style.width = (p.hp/stats[p.t].hp*100)+'%'; hb.appendChild(hf); cell.appendChild(hb);
                    }
                    cell.onmousedown = (e) => { if(audioCtx.state==='suspended') audioCtx.resume(); handleClick(r,c,e); };
                    if(sel && sel.r===r && sel.c===c) cell.classList.add('selected');
                    if(moves.some(m=>m.r===r&&m.c===c)) cell.classList.add('valid-move');
                    if(shoots.some(m=>m.r===r&&m.c===c)) cell.classList.add('valid-shoot');
                    el.appendChild(cell);
                }
            }
            const sb = document.getElementById('status-bar');
            sb.innerText = isMyTurn ? "ТВОЙ ХОД" : "ХОД ПРОТИВНИКА";
            sb.style.background = turn === 'white' ? '#eee' : '#333';
            sb.style.color = turn === 'white' ? '#000' : '#fff';
        }

        async function handleClick(r,c,e) {
            if(turn !== myCol) return;
            const p = board[r][c];
            if(!sel) {
                if(p && p.c===turn) {
                    sel={r,c};
                    if(e.button===0) { moves=getMoves(r,c,false); shoots=[]; }
                    else { shoots=getMoves(r,c,true); moves=[]; }
                }
            } else {
                const move = moves.find(m=>m.r===r&&m.c===c);
                const shoot = shoots.find(s=>s.r===r&&s.c===c);
                if(move) {
                    const action = { type:'action', move: {fromR:sel.r, fromC:sel.c, toR:r, toC:c}, nextTurn: turn };
                    // Local update
                    play(300, 'sine', 0.1);
                    board[r][c] = {...board[sel.r][sel.c], m:1}; board[sel.r][sel.c]=null;
                    sel={r,c}; moves=[]; shoots=getMoves(r,c,true);
                    if(shoots.length === 0) {
                        action.nextTurn = turn==='white'?'black':'white';
                        turn = action.nextTurn; sel=null;
                    } else {
                        // Still my turn, but moved. Wait for shoot or skip.
                    }
                    if(conn) conn.send(action);
                } else if(shoot) {
                    const dmg = stats[board[sel.r][sel.c].t].d;
                    const action = { type:'action', shoot: {fromR:sel.r, fromC:sel.c, toR:r, toC:c, dmg: dmg}, nextTurn: turn==='white'?'black':'white' };
                    // Local FX
                    await shootFX(sel.r, sel.c, r, c);
                    board[r][c].hp -= dmg;
                    if(board[r][c].hp<=0) board[r][c]=null;
                    turn = action.nextTurn; sel=null; moves=[]; shoots=[];
                    if(conn) conn.send(action);
                } else { sel=null; moves=[]; shoots=[]; }
            }
            render();
        }

        function getMoves(r,c,isS) {
            let res=[]; const p=board[r][c], d=p.c==='white'?-1:1;
            if(p.t==='p') {
                if(!isS) {
                    if(board[r+d] && !board[r+d][c]) { res.push({r:r+d,c}); if(!p.m && board[r+2*d] && !board[r+2*d][c]) res.push({r:r+2*d,c}); }
                    [[d,1],[d,-1]].forEach(v=>{ let nr=r+v[0], nc=c+v[1]; if(board[nr]&&board[nr][nc]&&board[nr][nc].c!==p.c&&board[nr][nc].t!=='k') res.push({r:nr,c:nc}); });
                } else [[d,1],[d,-1]].forEach(v=>{ let nr=r+v[0], nc=c+v[1]; if(board[nr]&&board[nr][nc]&&board[nr][nc].c!==p.c) res.push({r:nr,c:nc}); });
            } else if(p.t==='n') {
                [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]].forEach(v=>{
                    let nr=r+v[0], nc=c+v[1]; if(board[nr] && board[nr][nc]!==undefined) {
                        if(!board[nr][nc] || (board[nr][nc].c!==p.c && (isS || board[nr][nc].t!=='k'))) res.push({r:nr,c:nc});
                    }
                });
            } else {
                const dirs = p.t==='r' ? [[0,1],[0,-1],[1,0],[-1,0]] : p.t==='b' ? [[1,1],[1,-1],[-1,1],[-1,-1]] : [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
                dirs.forEach(v=>{
                    for(let i=1;i<8;i++){
                        let nr=r+v[0]*i, nc=c+v[1]*i; if(nr<0||nr>=8||nc<0||nc>=8)break;
                        if(!board[nr][nc]) { if(!isS) res.push({r:nr,c:nc}); }
                        else { if(board[nr][nc].c!==p.c && (isS||board[nr][nc].t!=='k')) res.push({r:nr,c:nc}); break; }
                    }
                });
            }
            return res;
        }

        async function shootFX(fr, fc, tr, tc) {
            const layer = document.getElementById('fx-layer');
            const rect = document.getElementById('board').getBoundingClientRect();
            const cw = rect.width / 8;
            function getCoords(r, c) {
                let dr = myCol === 'black' ? r : 7-r;
                let dc = myCol === 'black' ? 7-c : c;
                return { x: dc * cw + cw/2, y: dr * cw + cw/2 };
            }
            const s = getCoords(fr, fc), e = getCoords(tr, tc);
            const b = document.createElement('div'); b.className = 'bullet'; b.style.left = s.x+'px'; b.style.top = s.y+'px';
            layer.appendChild(b);
            play(400, 'sawtooth', 0.1);
            const start = performance.now();
            return new Promise(res => {
                function anim(t) {
                    const p = Math.min((t-start)/300, 1);
                    b.style.left = s.x + (e.x-s.x)*p+'px'; b.style.top = s.y + (e.y-s.y)*p+'px';
                    if (p<1) requestAnimationFrame(anim);
                    else {
                        b.remove(); const ex = document.createElement('div'); ex.className = 'explosion';
                        ex.style.left = (e.x-25)+'px'; ex.style.top = (e.y-25)+'px';
                        layer.appendChild(ex); play(100, 'square', 0.2, 0.2);
                        setTimeout(() => { ex.remove(); res(); }, 300);
                    }
                }
                requestAnimationFrame(anim);
            });
        }

        function copyInvite() {
            const url = window.location.origin + window.location.pathname + "?join=" + document.getElementById('my-id').innerText;
            navigator.clipboard.writeText(url); alert("ССЫЛКА СКОПИРОВАНА!");
        }

        init();
    </script>
</body>
</html>